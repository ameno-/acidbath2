---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
  title?: string;
  maxTopLevel?: number;
}

const { headings, title = 'On This Page', maxTopLevel = 8 } = Astro.props;

// Filter to only show h2 and h3 headings
const tocHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 3);

// Group h3s under their parent h2
interface HeadingGroup {
  h2: Heading;
  h3s: Heading[];
}

const headingGroups: HeadingGroup[] = [];
let currentGroup: HeadingGroup | null = null;

tocHeadings.forEach(heading => {
  if (heading.depth === 2) {
    currentGroup = { h2: heading, h3s: [] };
    headingGroups.push(currentGroup);
  } else if (heading.depth === 3 && currentGroup) {
    currentGroup.h3s.push(heading);
  }
});

const totalSections = headingGroups.length;
const showMoreButton = totalSections > maxTopLevel;
const initialGroups = showMoreButton ? headingGroups.slice(0, maxTopLevel) : headingGroups;
const hiddenGroups = showMoreButton ? headingGroups.slice(maxTopLevel) : [];
---

{tocHeadings.length > 0 && (
  <aside class="toc-sidebar" aria-label="Table of contents">
    <nav class="toc-nav">
      <div class="toc-header">
        <span class="toc-title">{title}</span>
        <span class="toc-count">{totalSections} sections</span>
      </div>
      <div class="toc-progress-bar">
        <div class="toc-progress-fill"></div>
      </div>
      <div class="toc-groups">
        {initialGroups.map((group) => (
          <details class="toc-group" data-slug={group.h2.slug} open={group.h3s.length === 0}>
            <summary class="toc-group-summary">
              <span class="toc-chevron">▸</span>
              <a href={`#${group.h2.slug}`} class="toc-link toc-link-h2" data-slug={group.h2.slug}>
                {group.h2.text}
              </a>
              {group.h3s.length > 0 && (
                <span class="toc-subcount">({group.h3s.length})</span>
              )}
            </summary>
            {group.h3s.length > 0 && (
              <ul class="toc-sublist">
                {group.h3s.map((h3) => (
                  <li class="toc-item toc-depth-3">
                    <a href={`#${h3.slug}`} class="toc-link toc-link-h3" data-slug={h3.slug}>
                      {h3.text}
                    </a>
                  </li>
                ))}
              </ul>
            )}
          </details>
        ))}
        {showMoreButton && (
          <div class="toc-hidden-groups" style="display: none;">
            {hiddenGroups.map((group) => (
              <details class="toc-group" data-slug={group.h2.slug}>
                <summary class="toc-group-summary">
                  <span class="toc-chevron">▸</span>
                  <a href={`#${group.h2.slug}`} class="toc-link toc-link-h2" data-slug={group.h2.slug}>
                    {group.h2.text}
                  </a>
                  {group.h3s.length > 0 && (
                    <span class="toc-subcount">({group.h3s.length})</span>
                  )}
                </summary>
                {group.h3s.length > 0 && (
                  <ul class="toc-sublist">
                    {group.h3s.map((h3) => (
                      <li class="toc-item toc-depth-3">
                        <a href={`#${h3.slug}`} class="toc-link toc-link-h3" data-slug={h3.slug}>
                          {h3.text}
                        </a>
                      </li>
                    ))}
                  </ul>
                )}
              </details>
            ))}
          </div>
        )}
      </div>
      {showMoreButton && (
        <button class="toc-show-more" aria-label="Show more sections">
          <span class="show-more-text">Show {hiddenGroups.length} more</span>
          <span class="show-less-text">Show less</span>
        </button>
      )}
    </nav>
  </aside>
)}

<script>
  /**
   * Enhanced Table of Contents with hierarchical grouping and scroll progress
   */
  function initEnhancedToc() {
    const tocSidebar = document.querySelector('.toc-sidebar');
    if (!tocSidebar) return;

    const tocLinks = document.querySelectorAll<HTMLAnchorElement>('.toc-link');
    const tocGroups = document.querySelectorAll<HTMLDetailsElement>('.toc-group');
    const progressFill = document.querySelector<HTMLDivElement>('.toc-progress-fill');
    const showMoreButton = document.querySelector<HTMLButtonElement>('.toc-show-more');
    const hiddenGroupsContainer = document.querySelector<HTMLDivElement>('.toc-hidden-groups');

    // Get all headings from the page
    const headings = Array.from(tocLinks).map(link => {
      const slug = link.getAttribute('data-slug');
      return slug ? document.getElementById(slug) : null;
    }).filter((el): el is HTMLElement => el !== null);

    if (headings.length === 0) return;

    let currentActiveSlug: string | null = null;

    // Update scroll progress bar
    function updateScrollProgress() {
      if (!progressFill) return;

      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const scrolled = window.scrollY;
      const progress = (scrolled / docHeight) * 100;

      progressFill.style.width = `${Math.min(progress, 100)}%`;
    }

    // Set active heading and expand parent group
    function setActiveHeading(slug: string) {
      if (slug === currentActiveSlug) return;
      currentActiveSlug = slug;

      tocLinks.forEach(link => {
        const linkSlug = link.getAttribute('data-slug');
        const isActive = linkSlug === slug;
        link.classList.toggle('active', isActive);

        // Expand parent group if this is an h3
        if (isActive && link.classList.contains('toc-link-h3')) {
          const parentDetails = link.closest<HTMLDetailsElement>('.toc-group');
          if (parentDetails) {
            parentDetails.open = true;
          }
        }
      });

      // Highlight active group
      tocGroups.forEach(group => {
        const groupSlug = group.getAttribute('data-slug');
        const isActiveGroup = groupSlug === slug;
        group.classList.toggle('is-active', isActiveGroup);
      });
    }

    // Initialize from URL hash
    function initFromUrlHash() {
      const hash = window.location.hash.slice(1);
      if (hash) {
        const heading = document.getElementById(hash);
        if (heading && headings.includes(heading)) {
          setActiveHeading(hash);
        }
      }
    }

    // Handle hash changes
    function handleHashChange() {
      const hash = window.location.hash.slice(1);
      if (hash) {
        const heading = document.getElementById(hash);
        if (heading && headings.includes(heading)) {
          setActiveHeading(hash);
        }
      }
    }

    // Intersection Observer for active tracking
    const observer = new IntersectionObserver(
      (entries) => {
        const visibleEntries = entries.filter(e => e.isIntersecting);

        if (visibleEntries.length > 0) {
          const topEntry = visibleEntries.reduce((prev, curr) => {
            return prev.boundingClientRect.top < curr.boundingClientRect.top ? prev : curr;
          });

          const id = topEntry.target.id;
          setActiveHeading(id);
        } else if (entries.length > 0) {
          const allHeadings = headings.map(h => ({
            id: h.id,
            top: h.getBoundingClientRect().top
          }));

          const viewportCenter = window.innerHeight / 2;
          const headingsAboveCenter = allHeadings.filter(h => h.top < viewportCenter);

          if (headingsAboveCenter.length > 0) {
            const closest = headingsAboveCenter.reduce((prev, curr) => {
              return Math.abs(curr.top - viewportCenter) < Math.abs(prev.top - viewportCenter) ? curr : prev;
            });
            setActiveHeading(closest.id);
          }
        }
      },
      {
        rootMargin: '-20% 0px -20% 0px',
        threshold: [0, 0.1, 0.25, 0.5, 0.75, 1]
      }
    );

    headings.forEach(heading => observer.observe(heading));

    // Scroll event for progress bar
    let scrollTimeout: ReturnType<typeof setTimeout>;
    function handleScroll() {
      updateScrollProgress();

      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        const viewportTop = window.scrollY + window.innerHeight * 0.2;
        let closestHeadingId: string | null = null;
        let closestDistance = Infinity;

        headings.forEach((heading: HTMLElement) => {
          const headingTop = heading.offsetTop;
          const distance = Math.abs(headingTop - viewportTop);

          if (headingTop <= viewportTop + 100 && distance < closestDistance) {
            closestDistance = distance;
            closestHeadingId = heading.id;
          }
        });

        if (closestHeadingId) {
          setActiveHeading(closestHeadingId);
        }
      }, 100);
    }

    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('hashchange', handleHashChange);

    // Show more functionality
    if (showMoreButton && hiddenGroupsContainer) {
      let expanded = false;

      showMoreButton.addEventListener('click', () => {
        expanded = !expanded;
        hiddenGroupsContainer.style.display = expanded ? 'block' : 'none';
        showMoreButton.classList.toggle('expanded', expanded);
      });
    }

    // Smooth scroll with history
    tocLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const slug = link.getAttribute('data-slug');
        if (slug) {
          const target = document.getElementById(slug);
          if (target) {
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            history.pushState(null, '', `#${slug}`);
            setActiveHeading(slug);
          }
        }
      });
    });

    // Prevent details toggle from triggering link navigation
    tocGroups.forEach(group => {
      const summary = group.querySelector('summary');
      if (summary) {
        summary.addEventListener('click', (e) => {
          const target = e.target as HTMLElement;
          // Only prevent default if clicking the summary itself, not the link
          if (target.tagName !== 'A') {
            // Let the details toggle naturally
          } else {
            e.stopPropagation(); // Prevent details toggle when clicking link
          }
        });
      }
    });

    // Initialize
    initFromUrlHash();
    updateScrollProgress();

    // Cleanup
    return () => {
      headings.forEach(heading => observer.unobserve(heading));
      window.removeEventListener('hashchange', handleHashChange);
      window.removeEventListener('scroll', handleScroll);
      clearTimeout(scrollTimeout);
    };
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEnhancedToc);
  } else {
    initEnhancedToc();
  }
  document.addEventListener('astro:after-swap', initEnhancedToc);
  document.addEventListener('astro:page-load', initEnhancedToc);
</script>
